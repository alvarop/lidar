#include <stdio.h>
#include <stdlib.h>
#include <bsp/bsp.h>
#include <console/console.h>
#include <hal/hal_gpio.h>
#include <os/os.h>
#include <sysinit/sysinit.h>
#include <hal/hal_spi.h>
#include <mcu/stm32_hal.h>
#include <ws2812b/ws2812b.h>


static SPI_HandleTypeDef hspi1;
static DMA_HandleTypeDef hdma_spi1_tx;

static struct os_sem sem_writing;

static struct os_callout ws2812b_callout;

static uint32_t refresh_ticks = 100;

// Number of actual bytes it takes to encode WS2812 byte with 3MHz spi clock
#define BYTE_LEN (3)

static uint8_t pattern[BYTE_LEN * 3 * WS2812B_NUM_PIXELS];

ws2812b_led_t leds[WS2812B_NUM_PIXELS];



// Look up table for all 256 bytes
static const uint8_t ws2812b_lut[256][BYTE_LEN] = {
    {0x92,0x49,0x24},{0x92,0x49,0x26},{0x92,0x49,0x34},{0x92,0x49,0x36},{0x92,0x49,0xA4},{0x92,0x49,0xA6},{0x92,0x49,0xB4}, {0x92,0x49,0xB6},
    {0x92,0x4D,0x24},{0x92,0x4D,0x26},{0x92,0x4D,0x34},{0x92,0x4D,0x36},{0x92,0x4D,0xA4},{0x92,0x4D,0xA6},{0x92,0x4D,0xB4}, {0x92,0x4D,0xB6},
    {0x92,0x69,0x24},{0x92,0x69,0x26},{0x92,0x69,0x34},{0x92,0x69,0x36},{0x92,0x69,0xA4},{0x92,0x69,0xA6},{0x92,0x69,0xB4}, {0x92,0x69,0xB6},
    {0x92,0x6D,0x24},{0x92,0x6D,0x26},{0x92,0x6D,0x34},{0x92,0x6D,0x36},{0x92,0x6D,0xA4},{0x92,0x6D,0xA6},{0x92,0x6D,0xB4}, {0x92,0x6D,0xB6},
    {0x93,0x49,0x24},{0x93,0x49,0x26},{0x93,0x49,0x34},{0x93,0x49,0x36},{0x93,0x49,0xA4},{0x93,0x49,0xA6},{0x93,0x49,0xB4}, {0x93,0x49,0xB6},
    {0x93,0x4D,0x24},{0x93,0x4D,0x26},{0x93,0x4D,0x34},{0x93,0x4D,0x36},{0x93,0x4D,0xA4},{0x93,0x4D,0xA6},{0x93,0x4D,0xB4}, {0x93,0x4D,0xB6},
    {0x93,0x69,0x24},{0x93,0x69,0x26},{0x93,0x69,0x34},{0x93,0x69,0x36},{0x93,0x69,0xA4},{0x93,0x69,0xA6},{0x93,0x69,0xB4}, {0x93,0x69,0xB6},
    {0x93,0x6D,0x24},{0x93,0x6D,0x26},{0x93,0x6D,0x34},{0x93,0x6D,0x36},{0x93,0x6D,0xA4},{0x93,0x6D,0xA6},{0x93,0x6D,0xB4}, {0x93,0x6D,0xB6},
    {0x9A,0x49,0x24},{0x9A,0x49,0x26},{0x9A,0x49,0x34},{0x9A,0x49,0x36},{0x9A,0x49,0xA4},{0x9A,0x49,0xA6},{0x9A,0x49,0xB4}, {0x9A,0x49,0xB6},
    {0x9A,0x4D,0x24},{0x9A,0x4D,0x26},{0x9A,0x4D,0x34},{0x9A,0x4D,0x36},{0x9A,0x4D,0xA4},{0x9A,0x4D,0xA6},{0x9A,0x4D,0xB4}, {0x9A,0x4D,0xB6},
    {0x9A,0x69,0x24},{0x9A,0x69,0x26},{0x9A,0x69,0x34},{0x9A,0x69,0x36},{0x9A,0x69,0xA4},{0x9A,0x69,0xA6},{0x9A,0x69,0xB4}, {0x9A,0x69,0xB6},
    {0x9A,0x6D,0x24},{0x9A,0x6D,0x26},{0x9A,0x6D,0x34},{0x9A,0x6D,0x36},{0x9A,0x6D,0xA4},{0x9A,0x6D,0xA6},{0x9A,0x6D,0xB4}, {0x9A,0x6D,0xB6},
    {0x9B,0x49,0x24},{0x9B,0x49,0x26},{0x9B,0x49,0x34},{0x9B,0x49,0x36},{0x9B,0x49,0xA4},{0x9B,0x49,0xA6},{0x9B,0x49,0xB4}, {0x9B,0x49,0xB6},
    {0x9B,0x4D,0x24},{0x9B,0x4D,0x26},{0x9B,0x4D,0x34},{0x9B,0x4D,0x36},{0x9B,0x4D,0xA4},{0x9B,0x4D,0xA6},{0x9B,0x4D,0xB4}, {0x9B,0x4D,0xB6},
    {0x9B,0x69,0x24},{0x9B,0x69,0x26},{0x9B,0x69,0x34},{0x9B,0x69,0x36},{0x9B,0x69,0xA4},{0x9B,0x69,0xA6},{0x9B,0x69,0xB4}, {0x9B,0x69,0xB6},
    {0x9B,0x6D,0x24},{0x9B,0x6D,0x26},{0x9B,0x6D,0x34},{0x9B,0x6D,0x36},{0x9B,0x6D,0xA4},{0x9B,0x6D,0xA6},{0x9B,0x6D,0xB4}, {0x9B,0x6D,0xB6},
    {0xD2,0x49,0x24},{0xD2,0x49,0x26},{0xD2,0x49,0x34},{0xD2,0x49,0x36},{0xD2,0x49,0xA4},{0xD2,0x49,0xA6},{0xD2,0x49,0xB4}, {0xD2,0x49,0xB6},
    {0xD2,0x4D,0x24},{0xD2,0x4D,0x26},{0xD2,0x4D,0x34},{0xD2,0x4D,0x36},{0xD2,0x4D,0xA4},{0xD2,0x4D,0xA6},{0xD2,0x4D,0xB4}, {0xD2,0x4D,0xB6},
    {0xD2,0x69,0x24},{0xD2,0x69,0x26},{0xD2,0x69,0x34},{0xD2,0x69,0x36},{0xD2,0x69,0xA4},{0xD2,0x69,0xA6},{0xD2,0x69,0xB4}, {0xD2,0x69,0xB6},
    {0xD2,0x6D,0x24},{0xD2,0x6D,0x26},{0xD2,0x6D,0x34},{0xD2,0x6D,0x36},{0xD2,0x6D,0xA4},{0xD2,0x6D,0xA6},{0xD2,0x6D,0xB4}, {0xD2,0x6D,0xB6},
    {0xD3,0x49,0x24},{0xD3,0x49,0x26},{0xD3,0x49,0x34},{0xD3,0x49,0x36},{0xD3,0x49,0xA4},{0xD3,0x49,0xA6},{0xD3,0x49,0xB4}, {0xD3,0x49,0xB6},
    {0xD3,0x4D,0x24},{0xD3,0x4D,0x26},{0xD3,0x4D,0x34},{0xD3,0x4D,0x36},{0xD3,0x4D,0xA4},{0xD3,0x4D,0xA6},{0xD3,0x4D,0xB4}, {0xD3,0x4D,0xB6},
    {0xD3,0x69,0x24},{0xD3,0x69,0x26},{0xD3,0x69,0x34},{0xD3,0x69,0x36},{0xD3,0x69,0xA4},{0xD3,0x69,0xA6},{0xD3,0x69,0xB4}, {0xD3,0x69,0xB6},
    {0xD3,0x6D,0x24},{0xD3,0x6D,0x26},{0xD3,0x6D,0x34},{0xD3,0x6D,0x36},{0xD3,0x6D,0xA4},{0xD3,0x6D,0xA6},{0xD3,0x6D,0xB4}, {0xD3,0x6D,0xB6},
    {0xDA,0x49,0x24},{0xDA,0x49,0x26},{0xDA,0x49,0x34},{0xDA,0x49,0x36},{0xDA,0x49,0xA4},{0xDA,0x49,0xA6},{0xDA,0x49,0xB4}, {0xDA,0x49,0xB6},
    {0xDA,0x4D,0x24},{0xDA,0x4D,0x26},{0xDA,0x4D,0x34},{0xDA,0x4D,0x36},{0xDA,0x4D,0xA4},{0xDA,0x4D,0xA6},{0xDA,0x4D,0xB4}, {0xDA,0x4D,0xB6},
    {0xDA,0x69,0x24},{0xDA,0x69,0x26},{0xDA,0x69,0x34},{0xDA,0x69,0x36},{0xDA,0x69,0xA4},{0xDA,0x69,0xA6},{0xDA,0x69,0xB4}, {0xDA,0x69,0xB6},
    {0xDA,0x6D,0x24},{0xDA,0x6D,0x26},{0xDA,0x6D,0x34},{0xDA,0x6D,0x36},{0xDA,0x6D,0xA4},{0xDA,0x6D,0xA6},{0xDA,0x6D,0xB4}, {0xDA,0x6D,0xB6},
    {0xDB,0x49,0x24},{0xDB,0x49,0x26},{0xDB,0x49,0x34},{0xDB,0x49,0x36},{0xDB,0x49,0xA4},{0xDB,0x49,0xA6},{0xDB,0x49,0xB4}, {0xDB,0x49,0xB6},
    {0xDB,0x4D,0x24},{0xDB,0x4D,0x26},{0xDB,0x4D,0x34},{0xDB,0x4D,0x36},{0xDB,0x4D,0xA4},{0xDB,0x4D,0xA6},{0xDB,0x4D,0xB4}, {0xDB,0x4D,0xB6},
    {0xDB,0x69,0x24},{0xDB,0x69,0x26},{0xDB,0x69,0x34},{0xDB,0x69,0x36},{0xDB,0x69,0xA4},{0xDB,0x69,0xA6},{0xDB,0x69,0xB4}, {0xDB,0x69,0xB6},
    {0xDB,0x6D,0x24},{0xDB,0x6D,0x26},{0xDB,0x6D,0x34},{0xDB,0x6D,0x36},{0xDB,0x6D,0xA4},{0xDB,0x6D,0xA6},{0xDB,0x6D,0xB4}, {0xDB,0x6D,0xB6},
};


void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi) {

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(hspi->Instance==SPI1) {

    /* Peripheral clock enable */
    __HAL_RCC_SPI1_CLK_ENABLE();

    __HAL_RCC_GPIOA_CLK_ENABLE();
    /**SPI1 GPIO Configuration
    PA5     ------> SPI1_SCK
    PA7     ------> SPI1_MOSI
    */
    GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_7;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    /* SPI1 DMA Init */
    /* SPI1_TX Init */
    hdma_spi1_tx.Instance = DMA1_Channel3;
    hdma_spi1_tx.Init.Request = DMA_REQUEST_1;
    hdma_spi1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
    hdma_spi1_tx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_spi1_tx.Init.MemInc = DMA_MINC_ENABLE;
    hdma_spi1_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_spi1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_spi1_tx.Init.Mode = DMA_NORMAL;
    hdma_spi1_tx.Init.Priority = DMA_PRIORITY_HIGH;
    assert(HAL_DMA_Init(&hdma_spi1_tx) == HAL_OK);

    __HAL_LINKDMA(hspi,hdmatx,hdma_spi1_tx);

  }

}

void ws2812b_callout_fn(struct os_event *ev) {
    os_callout_reset(&ws2812b_callout, refresh_ticks);
    ws2812b_write();
}

void ws2812b_write() {
    // Only write if we're not already writing
    if(os_sem_pend(&sem_writing, 0) == OS_OK) {
        hal_gpio_write(MCU_GPIO_PORTB(13), 1);
        for(uint16_t index = 0; index < WS2812B_NUM_PIXELS; index++) {
            uint8_t *pixel_addr = &pattern[index * BYTE_LEN * 3];
            memcpy(&pixel_addr[0], ws2812b_lut[leds[index].green], BYTE_LEN);
            memcpy(&pixel_addr[BYTE_LEN], ws2812b_lut[leds[index].red], BYTE_LEN);
            memcpy(&pixel_addr[BYTE_LEN * 2], ws2812b_lut[leds[index].blue], BYTE_LEN);
        }
        hal_gpio_write(MCU_GPIO_PORTB(13), 0);
        hal_gpio_write(MCU_GPIO_PORTB(1), 1);
        HAL_SPI_Transmit_DMA(&hspi1, pattern, sizeof(pattern));
    }
}

int32_t ws2812b_set_period(uint32_t ms) {
    return os_time_ms_to_ticks(ms, &refresh_ticks);
}

void DMA1_Channel3_IRQHandler(void) {
  HAL_DMA_IRQHandler(&hdma_spi1_tx);
}

int32_t ws2812b_init(uint32_t period_ms) {

    os_sem_init(&sem_writing, 1);

    /* DMA controller clock enable */
    __HAL_RCC_DMA1_CLK_ENABLE();

    /* DMA interrupt init */
    /* DMA1_Channel3_IRQn interrupt configuration */
    HAL_NVIC_SetPriority(DMA1_Channel3_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(DMA1_Channel3_IRQn);
    NVIC_SetVector(DMA1_Channel3_IRQn, (uint32_t)DMA1_Channel3_IRQHandler);

    /* SPI1 parameter configuration*/
    hspi1.Instance = SPI1;
    hspi1.Init.Mode = SPI_MODE_MASTER;
    hspi1.Init.Direction = SPI_DIRECTION_2LINES;
    hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
    hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
    hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
    hspi1.Init.NSS = SPI_NSS_SOFT;
    hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;
    hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
    hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
    hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
    hspi1.Init.CRCPolynomial = 7;
    hspi1.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
    // Enabling NSSPMode causes gaps between bytes and breaks things!
    hspi1.Init.NSSPMode = SPI_NSS_PULSE_DISABLE;
    assert(HAL_SPI_Init(&hspi1) == HAL_OK);

    HAL_SPI_MspInit(&hspi1);

    for(uint16_t index = 0; index < WS2812B_NUM_PIXELS; index++) {
        leds[index].green = 0;
        leds[index].red = 0;
        leds[index].blue = 0;
    }

    ws2812b_set_period(period_ms);

    os_callout_init(&ws2812b_callout, os_eventq_dflt_get(), ws2812b_callout_fn, NULL);
    if(period_ms > 0) {
        os_callout_reset(&ws2812b_callout, refresh_ticks);
    }


    return 0;
}

void HAL_SPI_TxCpltCallback(SPI_HandleTypeDef *hspi) {
  if (hspi == &hspi1) {
    hal_gpio_write(MCU_GPIO_PORTB(1), 0);
    os_sem_release(&sem_writing);
  }
}
